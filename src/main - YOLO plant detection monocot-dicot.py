"""
Code used for targeting of the print head spray system. YOLO plant detetcion of dicots vs monocots
Code initially developed 2023 by Wesley Moss
Refer to Github for further details https://github.com/precision-sustainable-ag/precision-spray/
"""
import cv2
from  ultralytics import YOLO
import numpy as np
import time
import tkinter as tk
from PIL import Image, ImageTk
from math import *
from pymodbus.client import ModbusTcpClient
from arena_api.system import system
import multiprocessing
from datetime import datetime
from bisect import bisect_left

"""Physical Calibration"""
pixToMeters = 0.24/(739-51)#0.1/(320-215)#(9*0.0254)/(355-117.5)#(10*0.0254)/(475-185)   # ratio of  m to pixels in the actual frame, m/pix
centframePos = 0.25775  # distance from centre of frame to valves, m
sliderWidthDefault = 213.5 #Width of the columns that correspond to valve position
sliderCentreDefault = 0 #Adjusts the centre of the columns that align with the valves

"""Camera Setup"""
gammaValue = 0.45 #gamma correction
'''Flash on/off'''
flash = True #Flag for turning the flash on and off. Manually change in code before running to turn flash on/off
if flash:
    exposure_time = 400.0
    gain_db = 3.0
else:
    exposure_time = 20000.0
    gain_db = 19.0

"""YOLO setup"""
model_path = "best_1344x896_v0.2_nano.engine"  # Path to YOLO model
confidence = 0.2 #confidence threshold to process results

'''Default settings'''
valveTime = 5 # default valve open time, ms
camHeight = 1344 #height of image after processing
camWidth = 896 # width of image after processing #int((cropSize/3000)*camHeight)
cropSize = int(camWidth*3000/camHeight) # size to initially crop width to. 
sliderVelocityDefault = 0.799 # (0.19+0.064+0.002) # vehicle speed in m/s
frameLength = camHeight*pixToMeters # length of the frame in direction of travel, mchecks if PLC is connected
client = ModbusTcpClient('169.254.229.134') #initialise modbus at assigned IP 
hozLineLocDefault = 400#camHeight/2 # position of horizontal line that triggers the valve firing. Moved up to give algo more time before needing to fire
rowCount = 32 +1 # number of rows corresponding to the number of nozzles
slideDelayDefault = -7 # Time delay on firing. -5ms default to account for lag in firing
slideVOffsetDefault = 0 # Offset on the velocity
sliderPixDefault = 0 
sliderBufferDefault = 340
sliderFPSDefault = 4
sliderSquareDefault = 3     # default size of sqaure firing pattern
sliderSquareSpacingDefault = 10 # 
sliderGridHeightDefault = 30 # vertiical spacing of firing pixel array

snapBool = False #bool to flag if a snapshot should be taken
monocotBool = False # bool to target either monocots or dicots
gridBool = True # toggles grids in image on and off
recordBool = False # toggles recoridng of images on and off
classLabelBool = False # toggles display of class labels
buildFiringPixels = True    # builds firing pixels array 
segmentation = True #Flag to control if you want to segment or use bounding box
fireBool = False # flag to control the "Fire" button
squareBool = False #flag to control if a sqaure pattern is fired

'''Initialises GUI Windows'''
controllerWindow = tk.Tk()  # initializes this tk interpreter and creates the root window
controllerWindow.title("Quantum Sprinkler")    # define title of the root window
controllerWindow.geometry("800x800+50+50")    # define size of the root window
controllerWindow["bg"] = "lightgrey"     # define the background color of the root window
controllerWindow.resizable(0, 0)    # define if the root window is resizable or not for Vertical and horizontal

videoWindow = tk.Toplevel(controllerWindow)     # a new window derived from the root window "controllerwindow"
videoWindow.title("Camera") 
#videoWindow.geometry("820x600+50+50")   # define title of videowindow
videoWindow.resizable(0, 0)  # Cannot resize the window
lmain = tk.Label(videoWindow)   #create an empty label widget in the videoWindow
lmain.pack()    # adjust the size of the videowindow to fit the label lmain
videoWindow.withdraw()  # hide the window
showVideoWindow = False
showColourWindow = False

kernel = np.ones((6, 6), np.uint8) # used of for opencv dilation and erosion in main function

#Placeholder for lists of pixel positions that can be fired on by the vavles given system settings. Lists are generated by 
xFiringPixels = []
yFiringPixels = []

fire_array = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]] #array used to store times of when to fire valves. Each column correspond to a valve

start_time = time.time() #doesn't appear to be in use?

'''System functions'''

def testShot():  # Fires all of the valves
    global coil_array
    for i in range(len(coil_array)):
          #print("Fire all")
              try: 
                  client.write_coil(coil_array[i], True)
              except:
                  print("Misfire ",i+1)

def create_devices_with_tries(): # Creates device for the Lucid Camera
    
    device_infos = None
    selected_index = None
    while selected_index is None:
        device_infos = system.device_infos
        if len(device_infos) == 0:
            print("No camera connected\nPress ent=er to search again")
            input()
            continue
        print("Devices found:")
        for i in range(len(device_infos)):
            print(f"\t{i}. {device_infos[i]['model']} SN: {device_infos[i]['serial']}")

        while True:
            line = 0
            try:
                selected_index = int(line)
                if 0 <= selected_index < len(device_infos):
                    break
                else:
                    print(f"Please enter a valid number between 0 and {len(device_infos)-1}\n")
            except Exception as e:
                print("\nPlease enter a valid number\n")

    selected_model = device_infos[selected_index]['model']
    print(f"\nCreate device: {selected_model}...")
    while True:
        try:
            device = system.create_device(device_infos=device_infos[selected_index])[0]
            break
        except:
            print("failed to create device")
            time.sleep(0.1)
    
    return device

def getMouseClickPosition(mousePosition):   # get mouse click position
    global mouseX, mouseY
    global getPixelColor
    mouseX, mouseY = mousePosition.x, mousePosition.y
    getPixelColor = True

def showCameraFrameWindow():    # function to toggle the showVideoWindow and change the label text of the button
    global showVideoWindow
    
    if showVideoWindow == False:
        
        videoWindow.deiconify()
        showVideoWindow = True
        BShowVideo["text"] = "Hide Live Video feed"
    else:
        videoWindow.withdraw()
        showVideoWindow = False
        BShowVideo["text"] = "Show Live Video feed"

def segmentToggle(): #toggles whether the system is targeting based on the segmentation or bounding box result
    global segmentation
    if segmentation == True:
        segmentation = False
        BSegmentToggle["text"] = "Segment"

    else:
        segmentation = True
        BSegmentToggle["text"] = "BBox"

def classLableToggle(): #toggles display of model class labels and YOLO verbose
    global classLabelBool
    if classLabelBool:
        classLabelBool = False
    else:
        classLabelBool = True

def snapToggle(): #flags that a snapshot should be taken
    global snapBool
    if snapBool:
        snapBool = False
    else:
        snapBool = True

def monocotToggle(): #toggles targeting between monocots and dicots
    global monocotBool
    if monocotBool:
        monocotBool = False
        BMonocot["text"] = "Targeting dicots"
    else:
        monocotBool = True
        BMonocot["text"] = "Targeting monocots"

def pixelRefresh(): #updates tje firing pixel array
    global buildFiringPixels
    if buildFiringPixels:
        buildFiringPixels = False
    else:
        buildFiringPixels =True

def setValveTime(t): # sets open time of the valves, t in ms. Must be connected to PLC
    status = False
    for i in range(5):
            
            try:
                client.write_register(0,int(t)) # sets PLC valve open time to valveOpenTime in ms
                print("Valve open time set to ",t)
                status = True
                break
            except:
                print("Valve open time setting failed, count ",i+1)
    return(status)

def valveOpenTime(): #linked to button that sets valve open time and updates label in GUI
    global valveTime
    if valveTime == 5:
        valveTime = 10
        success = setValveTime(valveTime)
        if success:
            label.configure(text="Valve Open Time 10ms", fg="red")
    elif valveTime == 10:
        valveTime = 20
        success = setValveTime(valveTime)
        if success:
            label.configure(text="Valve Open Time 20ms", fg="red")
    elif valveTime == 20:
        valveTime = 30
        success = setValveTime(valveTime)
        if success:
            label.configure(text="Valve Open Time 30ms", fg="red")
    elif valveTime == 30:
        valveTime = 5
        success = setValveTime(valveTime)
        if success:
            label.configure(text="Valve Open Time 5ms", fg="red")
    
def fireToggle(): #toggles the Fire Bool. Controls if system will fire valves or not
    global fireBool
    global label
    global BFire
    if fireBool:
        fireBool = False
        
        BFire["text"] = "Fire"
    else: 
        fireBool = True
        BFire["text"] = "Fire Off"
        #label.configure(text="Fire On", fg="#36db8b")
        
def squareToggle(): # toggles square firing pattern flag on and off 
    global squareBool
    if squareBool:
        squareBool = False
        BSquare["text"] = "Square pattern"

    else:
        squareBool = True
        BSquare["text"] = "Single shot"

def recordFire(): #toggles the recordBool. Images of firing events will be saved if this is on.
    global recordBool

    if recordBool:
        recordBool = False
        
        BRecord["text"] = "Record On"
    else: 
        recordBool = True
        BRecord["text"] = "Record Off"

def endProgam():        # function to close root window, packup lucid camera and processes.
    try:
        devices.stop_stream()
        system.destroy_device()
    except:
        print("didn't terminate camera")

    controllerWindow.destroy()
    p1.terminate()
    #cv2.destroyAllWindows()
    

def gridToggle(): # toggles grid lines on and off in the image
    global gridBool
    if gridBool:
        gridBool = False
    else:
        gridBool = True


def plcConnect(): #checks if PLC is connected
    plc_res = client.connect() 
    if plc_res:
       print("Connected to PLC")
    else: 
        print("No connection to PLC")

def donothing():  # function that does nothing
    pass

def fire(nn):  #function to trigger valves in print head.  fire(nn) triggers valve nn+1. 
    global coil_array
    
    try:
        client.write_coil(coil_array[(nn)], True)
        
    except:
        try:
            client.write_coil(coil_array[(nn)], True)
           
        except:
            print("Misfire ",nn)

coil_array = [] # array of modbus addresses for each valve output on the PLC. 
def gen_array():
    global coil_array
    for i in range(8224,8232):
        coil_array.append(i)
    for i in range(8256,8264):
        coil_array.append(i)
    for i in range(8288,8296):
        coil_array.append(i)
    for i in range(8320,8328):
        coil_array.append(i)

gen_array() #populates coil_array


def calibration(c): #calibration to account for positional errors from physical devictions in vavlves
    #200mm height. Calibration on 23-10-11
    dist_offset = 0
    if c == 1:
        dist_offset=3.0/1000
    # if c ==3:
    #     c=4 #use valve 5 (4+1) instead of valve 4 (3+1)
    if c ==7:
        c=8 #use valve 9 (8+1) instead of valve 8 )7+1)
    if c ==9:
        dist_offset=-2.0/1000
    if c==15:
        c=16 #use next valvle instead
    if c == 19:
        c = 20
    if c == 20:
         dist_offset=-5.0/1000
    if c == 23:
         c=24
    return(c, dist_offset)


def fireStore(c,y,ttime,q): # caluclates time valve should be fired based on vehicle velcity and object position in frame
    global fire_array, start_time
    vOffset= sliderVOffset.get()
    pixOffset = sliderPixOffset.get()/100000
    delay = sliderDelay.get()/1000.0
    vVel = sliderVelocity.get()
    
    c, dist_offset = calibration(c) #adjusts due to misalignments in valves
    dist = ((pixToMeters+pixOffset)*((camHeight/2)-y))+centframePos+dist_offset # distance between object and valve, m
    travTime = (dist/(vVel+vOffset))+delay # travel time between object and valve given vVel

    q.put([c,ttime+travTime, False]) #passes time to queue
 
    if(ttime+travTime-time.time()<0.008): #checks that the object isn't too close to valves
        print("delayed store", ttime+travTime-time.time())


def fireSquare(i,y,ttime,q): # stores a square of fire commands 
    global fire_array, start_time
    sqSize = int(sliderSquare.get())
    sqDelay = sliderSquareSpacing.get()/1000.0 # delay between sqaure firings
    vOffset= sliderVOffset.get()
    pixOffset = sliderPixOffset.get()/100000
    delay = sliderDelay.get()/1000.0
    vVel = sliderVelocity.get()
    
    dist = ((pixToMeters+pixOffset)*((camHeight/2)-y))+centframePos # distance between object and valve, m
    travTime = (dist/(vVel+vOffset))+delay # travel time between object and valve given vVel
    if sqSize %2 != 0:
        
        for d in range(int(1-((sqSize+1)/2)),int((sqSize+1)/2)):
            for r in range(int(1-((sqSize+1)/2)),int((sqSize+1)/2)):
                row = i + r
                #print("square", row)
                if row >= 0 and row<=31:
                    q.put([row,ttime+travTime + (d*sqDelay),True])
                    #print("put in queue,", i, d)
    else:
        for d in range(1-(sqSize)/2,(sqSize)/2):
            for row in range(1-(sqSize)/2,(sqSize)/2):
                i = i + row
                if i >= 0 and i<=31:
                    q.put([i,ttime+travTime + (d*sqDelay), True])


def doubleUpCheck(c,TT): #checks to see if there is a double up of times in adjacent columns
    check = True
    lowerBound = c-2 #two columns below and above will be checked
    upperBound = c+3
    if lowerBound < 0:
        lowerBound = 0
    if upperBound> 32:
        upperBound = 32
    if not segmentation:
        for i in range(lowerBound,upperBound):  
            if len(fire_array[i]) >0:
                    for r in range(len(fire_array[i])):
                        t = fire_array[i][r]
                        if abs(t-TT)<0.006:
                            check = False # There is a double up
                            #print("double up detected")
                            break
    if segmentation: # don't check adjacent sqaures
        if len(fire_array[c]) >0:
            for r in range(len(fire_array[c])):
                t = fire_array[c][r]
                if abs(t-TT)<0.006:
                    check = False # There is a double up
                    #print("double up detected")
                    break
    return check 


def multiProcessFireCheck(q):  #In a sperate process, gets travel time from queue, q, and checks if it should fire a valve
    while True:
        loopStart = time.time()
        try:
            val = q.get(block = False)
            c = val[0] #column to fire
            TT = val[1] # time transferred from the queue
            #squareFlag = val[2] #flag of whether a sqaure firing sequence
            if doubleUpCheck(c,TT):
                fire_array[c].append(TT) #only saves to array if doubleUpCheck shows there isn't a doubelup
            else:
                pass

        except:
                pass
        current_time = time.time()
        for i in range(32): #loops through each value in fire_array and checks if it is time to trigger valve
            if len(fire_array[i]) >0:
                for r in range(len(fire_array[i])):
                    try:
                        t = fire_array[i][r]
                        
                        if ((current_time - t)>=0):
                            fire(i)
                            #print("FIRE!")
                            fire_array[i].pop(r) #removes value frol fire_array
                            if ((current_time - t)>0.008): #checks if there was a delay in firing
                                print('Delayed firing 1: ',i,current_time - t)
                            break # break loop looking at this row as one was already found to fire this time
                    except:
                        t = 0

def find_closest(x,y): #Returns closest value to x and y in xFiringPixels and yFiringPixels respectively
    """ Assumes lists is sorted. If two numbers are equally close, return the smallest number. """
    global xFiringPixels, yFiringPixels

    pos = bisect_left(xFiringPixels, x)
    if pos == 0:
        x_ans= 0
    elif pos == len(xFiringPixels):
        x_ans= len(xFiringPixels)
    else:
        before = xFiringPixels[pos - 1]
        after = xFiringPixels[pos]
        if after - x < x - before:
            x_ans= pos
        else:
            x_ans= pos-1
    
    pos = bisect_left(yFiringPixels, y)
    if pos == 0:
        y_ans= 0
    elif pos == len(yFiringPixels):
        y_ans= len(yFiringPixels)
    else:
        before = yFiringPixels[pos - 1]
        after = yFiringPixels[pos]
        if after - y < y - before:
            y_ans= pos
        else:
            y_ans= pos-1
    return (x_ans,y_ans)

FrameTime = time.time() #iniital value for frame time. 

'''main function'''
def main():     
    global getPixelColor
    global x, y
    global monocotBool
    global start_time
    global showVideoWindow
    global FrameTime, segmentation
    global q, gridBool, model
    global xFiringPixels, yFiringPixels, buildFiringPixels, snapBool
         
    targetFPS = sliderFPS.get()
    if targetFPS !=0:
        TimeTarget = 1/targetFPS
    
        if (time.time()- FrameTime) >= TimeTarget:
           
            #print("FPS ", 1.0/ (time.time()- FrameTime))
            triggerFlag = False # flag to see if a trigger was sensed in this frame
            FrameTime = time.time()
            trigger = True
            try:
                nodemap['TriggerSoftware'].execute()
            except:
                print("failed to trigger")
                trigger = False
            if trigger:  
                image_buffer = devices.get_buffer()  # optional args
                img = np.ctypeslib.as_array(image_buffer.pdata,shape=(image_buffer.height, image_buffer.width, int(image_buffer.bits_per_pixel / 8))).reshape(image_buffer.height, image_buffer.width, int(image_buffer.bits_per_pixel / 8))
                                                               
                dim = (camWidth, camHeight) 
                dimF = (camHeight, camWidth)
            
                img = cv2.cvtColor(img, cv2.COLOR_BayerBG2BGR) #converts image from Bayer to BGR
                img = cv2.resize(img, dim, interpolation = cv2.INTER_AREA) # resizes image to camwidth and camheight
           
                            
                if classLabelBool:
                    results = model(img,conf=confidence,imgsz=dimF, verbose=True)  # return a list of Results objects from YOLO model
                else:
                    results = model(img,conf=confidence,imgsz=dimF, verbose=False)
                               

                height = img.shape[0]
                width = img.shape[1]
                width_gap = sliderWidth.get()
                centreOffset = sliderCentre.get()
                buffer = sliderBuffer.get()
                rowWidth = (width - (2*width_gap)) / rowCount
                gridHeight = sliderGridHeight.get()
                HozPos = sliderHoz.get()

                if buildFiringPixels: #builds firing pixel array used to map grid of possible firing locations onto segmentation model
                    buildFiringPixels = False
                    print("building firing pix array")
                    xFiringPixels = []
                    yFiringPixels = []
                   
                    for i in range(rowCount-1): #generates strips of vertical lines
                        x = rowWidth*(i+0.5) + centreOffset+ width_gap
                        xFiringPixels.append(x)
                    for j in range(int((camHeight)/gridHeight)):
                        y = gridHeight*(j+0.5)# +HozPos-buffer
                        yFiringPixels.append(y)
                    
                if gridBool and showVideoWindow:
                    cv2.line(img, (0, sliderHoz.get()), (width, sliderHoz.get()), (255, 0, 0), 2) # horizontal line
                    cv2.line(img, (0, sliderHoz.get()+buffer), (width, sliderHoz.get()+buffer), (255, 0, 0), 1) # Upper buffer line
                    cv2.line(img, (0, sliderHoz.get()-buffer), (width, sliderHoz.get()-buffer), (255, 0, 0), 1) # Lower buffer line
                    for i in range(rowCount): #generates strips of vertical lines
                        cv2.line(img, (int(width_gap + centreOffset+ (i*rowWidth)), 0), (int(width_gap + centreOffset + (i*rowWidth)), height), (255, 0, 0), 2) # vertical line
                
                              
                for r in results: #YOLO results
                    for result in r:
                        boxes = result.boxes
                        ID = boxes.cls
                        conf = boxes.conf

                        if ((int(ID[0]) ==1 or int(ID[0]) ==3) and monocotBool) or ((int(ID[0]) ==2 or int(ID[0]) ==4) and monocotBool==False): 
                                               
                            if segmentation == False: #bounding box method
                                
                                bbox = boxes.xywh #centre of bbox                            
                                try:
                                    x = float(bbox[0][0]) # x coordinate bbox centre
                                    y = float(bbox[0][1]) # y coordinate bbox centre
                                    
                                    cont = True # continue with firing check if a box is detected
                                except:
                                    cont = False
                                    print("couldn't find centre of bbox")
                                if cont:
                                    cv2.circle(img, (int(x), int(y)), int(1), (0, 255, 0), 3)
                                    if classLabelBool:
                                        cv2.putText(img,str(int(ID[0]))+" "+str(round(float(conf[0]),2)), (int(x)+10, int(y)+10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 1)
                                            
                                    if fireBool: # check if the fire bool is on
                                        
                                        if ((HozPos- buffer) < y < (HozPos+ buffer)): # checks if object is inside the firing buffer
                                            for i in range(rowCount-1): #checks which row it is in
                                                if (width_gap  + centreOffset+ (i*rowWidth)) <= x < (width_gap  + centreOffset+ ((i+1)*rowWidth)):
                                                    
                                                    i = 31-i # inverting row
                                                    
                                                    if squareBool:
                                                        fireSquare(i,y,FrameTime,q) #sqaure pattern
                                                    else:
                                                        fireStore(i,y,FrameTime,q) #single pattern
                                                        
                                                    cv2.circle(img, (int(x), int(y)), int(1), (255, 255, 0), 3) #red circle around the firing object
                                                    triggerFlag = True
                                                    
                            if segmentation == True: #segmentation method
                                
                                mask = result.masks
                                cent = mask.xy
                                bbox = boxes.xyxy #edge of bbox
                                bboxx = float(bbox[0][0]) # x coordinate
                                bboxy = float(bbox[0][1]) # y coordinate
                                bboxw = float(bbox[0][2])-bboxx #width
                                bboxh = float(bbox[0][3]) -bboxy #height
                                xpix, ypix = find_closest(bboxx,bboxy) #posiiton of closest points in the firingpixel arrays to the edge of the bbox

                                for i in range(xpix,(xpix+int(bboxw/rowWidth)+1),1): #Checks in bounding box for polygon test - does this segmentation instance contain a pixel from the pixel firing array
                                    if i>=len(xFiringPixels):
                                        x = int(xFiringPixels[-1])
                                    else:
                                        x = int(xFiringPixels[i])
                                    for j in range(ypix,(ypix+int(bboxh/gridHeight)+1),1):
                                        if j>=len(yFiringPixels):
                                            y = int(yFiringPixels[-1])
                                        else:
                                            y = int(yFiringPixels[j])
                                        
                                        if cv2.pointPolygonTest(cent[0], (x,y), False)== 1: #pixel is in the segmentation 
                                            cv2.circle(img, (x,y), int(1), (0, 255, 0), 3) # circle around the firing object
                                    
                                            if fireBool: # check if the fire bool is on

                                                if ((HozPos- buffer) < y < (HozPos+ buffer)): # checks if object is inside the firing buffer
                                                    for i in range(rowCount-1): #checks which row it is in
                                                        if (width_gap  + centreOffset+ (i*rowWidth)) <= x < (width_gap  + centreOffset+ ((i+1)*rowWidth)):
                                                            
                                                            i = 31-i # inverting row
                                                            if squareBool:
                                                                fireSquare(i,y,FrameTime,q) #sqaure pattern
                                                            else:
                                                                fireStore(i,y,FrameTime,q) #single pattern
                                                                
                                                            cv2.circle(img, (int(x), int(y)), int(1), (255, 255, 0), 3) #red circle around the firing object
                                                            triggerFlag = True           
                
                
                        elif showVideoWindow: #only looks for crop (mono/dicot depending on setting) if the video window is displayed
                            if segmentation == False: #bounding box method
                                    
                                    bbox = boxes.xywh #centre of bbox                            
                                    try:
                                        x = float(bbox[0][0]) # x coordinate
                                        y = float(bbox[0][1]) # y coordinate
                                        
                                        cont = True # continue with firing check if a box is detected
                                    except:
                                        cont = False
                                        print("couldn't find centre of bbox")
                                    if cont:
                                        cv2.circle(img, (int(x), int(y)), int(3), (0, 0, 255), 5)
                                        if classLabelBool:
                                            cv2.putText(img,str(int(ID[0]))+" "+str(round(float(conf[0]),2)), (int(x)+10, int(y)+10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 1)
                                               
                                                                    
                            if segmentation == True: #segmentation method
                                
                                mask = result.masks
                                cent = mask.xy
                                bbox = boxes.xyxy #edge of bbox
                                bboxx = float(bbox[0][0]) # x coordinate
                                bboxy = float(bbox[0][1]) # y coordinate
                                bboxw = float(bbox[0][2])-bboxx
                                bboxh = float(bbox[0][3]) -bboxy
                                xpix, ypix = find_closest(bboxx,bboxy) #posiiton of closest points in the firingpixel arrays
                                
                                for i in range(xpix,(xpix+int(bboxw/rowWidth)+1),1): #only looks in bounding box for polygon test
                                    if i>=len(xFiringPixels):
                                        x = int(xFiringPixels[-1])
                                    else:
                                        x = int(xFiringPixels[i])
                                    for j in range(ypix,(ypix+int(bboxh/gridHeight)+1),1):
                                        if j>=len(yFiringPixels):
                                            y = int(yFiringPixels[-1])
                                        else:
                                            y = int(yFiringPixels[j])
                                        
                                        if cv2.pointPolygonTest(cent[0], (x,y), False)== 1:
                                            cv2.circle(img, (x,y), int(3), (0,0,255, 5))

                 
                if showVideoWindow == True: #window showing the live camera feed
                    imgV = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) 
                    trans_img = Image.fromarray(imgV)
                    imgtk = ImageTk.PhotoImage(image=trans_img)
                    lmain.imgtk = imgtk
                    lmain.configure(image=imgtk)

                if recordBool and triggerFlag: # records the current video frame if there is a firing event  
                    current_time = datetime.now().astimezone()
                    
                    time_string = current_time.isoformat(timespec="milliseconds")
                    time_string = time_string.replace('+','_')
                    time_string = time_string.replace(':','_')
                    filename = f'Recordings/spray_record_{time_string}.jpg'
                    cv2.imwrite(filename, img)

                if snapBool: #takes a snapshot of the current video frame
                    snapBool = False
                    current_time = datetime.now().astimezone()
                    
                    time_string = current_time.isoformat(timespec="milliseconds")
                    time_string = time_string.replace('+','_')
                    time_string = time_string.replace(':','_')
                    filename = f'Recordings/snap_{time_string}.jpg'
                    cv2.imwrite(filename, img)
                    print("Snap saved")
                
                devices.requeue_buffer(image_buffer)   #requeues image buffer in lucid camera   

    lmain.after(5, main) #tkinter loop

'''Below code defines the function and layout of the TKinter GUI '''

FrameVideoControl = tk.LabelFrame(controllerWindow, text="Video Control")
FrameVideoControl.place(x=20, y=20, width=380)
EmptyLabel = tk.Label(FrameVideoControl)
EmptyLabel.pack()
BShowVideo = tk.Button(FrameVideoControl, text="Show Live Video feed", command=showCameraFrameWindow)
BShowVideo.place(x=100, y=-5)

sliderSquare=tk.Scale(controllerWindow, from_=3, to=15, orient="horizontal", label="Square Size", length=1000, tickinterval=2,
                       resolution=2)
sliderSquare.place(x=20, y=80, width=180, height=60)
sliderSquare.set(sliderSquareDefault)

BSquare = tk.Button(controllerWindow, text="Square Pattern", command=squareToggle, background="white")
BSquare.place(x=210, y=80)

sliderSquareSpacing=tk.Scale(controllerWindow, from_=1, to=100, orient="horizontal", label="Square Spacing", length=1000, tickinterval=1,
                       resolution=1)
sliderSquareSpacing.place(x=20, y=150, width=180, height=60)
sliderSquareSpacing.set(sliderSquareSpacingDefault)

sliderVelocity=tk.Scale(controllerWindow, from_=0, to=3, orient="horizontal", label="Vehicle Velocity", length=1000, tickinterval=0.01,
                       resolution=0.001)
sliderVelocity.place(x=20, y=220, width=370, height=60)
sliderVelocity.set(sliderVelocityDefault)

sliderHoz = tk.Scale(controllerWindow, from_=0, to=camHeight, orient="horizontal", label="Horizontal Line Offtset", length=95, tickinterval=1,
                       resolution=1)
sliderHoz.place(x=20, y=290, width=180, height=60)
sliderHoz.set(hozLineLocDefault)

sliderBuffer = tk.Scale(controllerWindow, from_=0, to=camHeight/2, orient="horizontal", label="Buffer", length=95, tickinterval=5,
                       resolution=5)
sliderBuffer.place(x=210, y=290, width=180, height=60)
sliderBuffer.set(sliderBufferDefault)

BFire = tk.Button(controllerWindow, text="Fire", command=fireToggle, background="white")
BFire.place(x=20, y=360)

label = tk.Label(controllerWindow, text="Valve Open Time 5ms", fg="red", anchor="ne")
label.pack(fill="both")

BPLC_Connect = tk.Button(controllerWindow, text="PLC Check", command=plcConnect)
BPLC_Connect.place(x=100, y=360)

BOpenTime = tk.Button(controllerWindow, text="Set Valve Time", command=valveOpenTime)
BOpenTime.place(x=205, y=360)

BTest_shot = tk.Button(controllerWindow, text="Test Shot", command=testShot)
BTest_shot.place(x=20, y=400)

BGridToggle = tk.Button(controllerWindow, text="Toggle Grid", command=gridToggle, background="white")
BGridToggle.place(x=120, y=400)

BRecord = tk.Button(controllerWindow, text="Record On", command=recordFire, background="white")
BRecord.place(x=230, y=400)

BSegmentToggle = tk.Button(controllerWindow, text="BBox", command=segmentToggle, background="white")
BSegmentToggle.place(x=20, y=440)

BClassLabel = tk.Button(controllerWindow, text="Class Label", command=classLableToggle, background="white")
BClassLabel.place(x=120, y=440)

BPixelGridRefresh = tk.Button(controllerWindow, text="Rebuild Pix Array", command=pixelRefresh)
BPixelGridRefresh.place(x=230, y=440)

BMonocot = tk.Button(controllerWindow, text="Targeting dicots", command=monocotToggle)
BMonocot.place(x=20, y=480)

BSnap = tk.Button(controllerWindow, text="Snap", command=snapToggle)
BSnap.place(x=230, y=480)

BQuit = tk.Button(controllerWindow, text="Quit", command=endProgam, background="red")
BQuit.place(x=20, y=520)

sliderWidth= tk.Scale(controllerWindow, from_=0, to=camWidth, orient="horizontal", label="Row Size", length=5000, tickinterval=10,
                       resolution=0)
sliderWidth.place(x=440, y=20, width=250, height=60)
sliderWidth.set(sliderWidthDefault)

sliderCentre= tk.Scale(controllerWindow, from_=-camWidth/2, to=camWidth/2, orient="horizontal", label="Spray centre offset", length=5000, tickinterval=1,
                       resolution=0)
sliderCentre.place(x=440, y=90, width=250, height=60)
sliderCentre.set(sliderCentreDefault)

sliderDelay= tk.Scale(controllerWindow, from_=-50, to=50, orient="horizontal", label="Fire Delay", length=1000, tickinterval=1,
                       resolution=1)
sliderDelay.place(x=440, y=160, width=250, height=60)
sliderDelay.set(slideDelayDefault)

sliderVOffset= tk.Scale(controllerWindow, from_=-0.2, to=0.2, orient="horizontal", label="Velocity Offset", length=1000, tickinterval=0.001,
                       resolution=0.001)
sliderVOffset.place(x=440, y=230, width=250, height=60)
sliderVOffset.set(slideVOffsetDefault)

sliderPixOffset= tk.Scale(controllerWindow, from_=-100, to=100, orient="horizontal", label="Pix2meter Offset", length=1000, tickinterval=1,
                       resolution=1)
sliderPixOffset.place(x=440, y=300, width=250, height=60)
sliderPixOffset.set(sliderPixDefault)

sliderFPS=tk.Scale(controllerWindow, from_=0, to=15, orient="horizontal", label="Frame Rate", length=1000, tickinterval=1,
                       resolution=0.5)
sliderFPS.place(x=440, y=370, width=250, height=60)
sliderFPS.set(sliderFPSDefault)

sliderGridHeight=tk.Scale(controllerWindow, from_=1, to=50, orient="horizontal", label="Firing Pixel Gird Height", length=1000, tickinterval=1,
                       resolution=1)
sliderGridHeight.place(x=440, y=440, width=250, height=60)
sliderGridHeight.set(sliderGridHeightDefault)


videoWindow.protocol("WM_DELETE_WINDOW", donothing)
videoWindow.bind("<Button-1>", getMouseClickPosition)
#videoWindow.bind("<Button-1>", setRefWithMouse)     # mouse click to set reference position

if __name__ == "__main__":
    plc_res = client.connect() #checks if PLC is connected
    if plc_res:
        print("Connected to PLC")
        setValveTime(valveTime)
    else: 
        print("Failed to connect to PLC")

      
    model = YOLO(model_path,task='segment') #YOLO model, segment must be explictily defined
    
    q = multiprocessing.Queue() # Queue to pass firing times between processes
    p1 = multiprocessing.Process(target=multiProcessFireCheck,args = (q,)) #seperate process where fire checking in performed
    p1.start() #starts process

    #initialise Lucid camera
    devices = create_devices_with_tries()
    nodemap = devices.nodemap
    nodes = nodemap.get_node(['ExposureAuto', 'ExposureTime', 'GainAuto', 'Gain', 'Width', 'OffsetX', 'Gamma',
                            'TriggerSelector', 'TriggerMode','TriggerSource','LineSelector','LineMode', 'LineSource', 'LineInverter'])
    nodes['ExposureAuto'].value = 'Off'
    nodes['ExposureTime'].value = exposure_time
    nodes['GainAuto'].value = 'Off'
    nodes['Gain'].value = gain_db
    nodes['Gamma'].value = gammaValue
    nodes['TriggerSelector'].value = 'FrameStart'
    nodes['TriggerMode'].value = 'On'
    nodes['TriggerSource'].value = 'Software'
    nodes['LineSelector'].value = 'Line3'
    nodes['LineMode'].value = 'Output'  
    nodes['LineInverter'].value = True
        
    nodes['Width'].value =  cropSize
    nodes['OffsetX'].value = int((4096-cropSize)/2)+200
    if flash:
        nodes['LineSource'].value = 'ExposureActive' 
    else:
        nodes['LineSource'].value = 'Off'
    devices.tl_stream_nodemap.get_node('StreamBufferHandlingMode').value = 'NewestOnly'
    devices.tl_stream_nodemap.get_node('StreamPacketResendEnable').value = True
    devices.tl_stream_nodemap.get_node('StreamAutoNegotiatePacketSize').value = True
    devices.nodemap.get_node('PixelFormat').value = "BayerRG8" 
    devices.start_stream()

    main()
    tk.mainloop()






